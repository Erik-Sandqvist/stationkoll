Jag är själv lite osäker på funktionen kring hur logiken blir när medarbetare ska placeras ut på stationer.
Dem ska inte kunna hammna på samma stationer två gånger i rad men när det tar slut på medarbetare för att fylla en station 
och det enda alternativet blir att ta en som har varit där gången innan kan det hända- Men det blir förmodligen väldigt sällan.
Koden som ska hantera detta: 
    // Filter out employees who were at this station last time
    // Then sort remaining by least time at this station
    const available = employeeHistories
      .filter((emp) => !assignedEmployees.has(emp.id))
      .filter((emp) => canAssignToStation(emp.id, station, lastStationsMap))
      .sort((a, b) => {
        const aCount = a.history[station] || 0;
        const bCount = b.history[station] || 0;
        return aCount - bCount;
      });

    for (let i = 0; i < needed && i < available.length; i++) {
      const employee = available[i];
      newAssignments[station].push(employee.id);
      assignedEmployees.add(employee.id);
    }
  }

  // If some employees couldn't be assigned due to last-station restriction,
  // try to assign them anyway (fallback)
  const unassignedDueToRestriction = employeeHistories
    .filter((emp) => !assignedEmployees.has(emp.id));
  
  if (unassignedDueToRestriction.length > 0) {
    // Try to fill remaining needs, ignoring the last-station rule
    for (const station of sortedStations) {
      const needed = stationNeeds[station] || 0;
      const currentCount = newAssignments[station]?.length || 0;
      
      if (currentCount < needed) {
        const stillAvailable = unassignedDueToRestriction
          .filter((emp) => !assignedEmployees.has(emp.id))
          .sort((a, b) => {
            const aCount = a.history[station] || 0;
            const bCount = b.history[station] || 0;
            return aCount - bCount;
          });
        
        for (let i = 0; i < (needed - currentCount) && i < stillAvailable.length; i++) {
          const employee = stillAvailable[i];
          if (!newAssignments[station]) newAssignments[station] = [];
          newAssignments[station].push(employee.id);
          assignedEmployees.add(employee.id);
        }
      }
    }
  }